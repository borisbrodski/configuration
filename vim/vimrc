" Use runtime! my.vim to use other files

call pathogen#runtime_append_all_bundles()
call pathogen#helptags()
runtime macros/matchit.vim

if has('win32')
	source $HOME/vimfiles/bundle/snipmate/plugin/snipMate.vim
	"source $HOME/vimfiles/bundle/snipmate/autoload/snipMate.vim
	call GetSnippets("C:/Users/brodski.boris/vimfiles/bundle/snipmate/snippets", "tex")
	call GetSnippets("C:/Users/brodski.boris/vimfiles/snippets/", "ant")
endif

set showmatch " Show matching brackets.
set ignorecase " Search ignoring case
set smartcase " Do smart case matching
set hlsearch
set incsearch
set hidden
set mouse=a
set selectmode=
set mousemodel=popup
set keymodel=startsel ",stopsel
set selection=old
set backspace=indent,eol,start
set whichwrap+=<,>,[,]
set cpoptions+=$
set showcmd
set ruler
set laststatus=2
set statusline=%F%m%r%h%w\ [%{&ff},%{&fileencoding}][%Y][\%03.3b,0x\%02.2B][%l/%L,%v]%p%%
set tag+=../tags
" --------------------------------------------------------------------------------
" COLORS
" --------------------------------------------------------------------------------
colorscheme torte

" Mode Indication -Prominent!
function! InsertStatuslineColor(mode)
  if a:mode == 'i'
    hi statusline guibg=#cc6666
    " set cursorcolumn
  elseif a:mode == 'r'
    hi statusline guibg=#33aaee
  else
    hi statusline guibg=#ee44bb
  endif
endfunction

function! InsertLeaveActions()
  hi statusline guibg=#ffffff
  set nocursorcolumn
endfunction

au InsertEnter * call InsertStatuslineColor(v:insertmode)
au InsertLeave * call InsertLeaveActions()

" to handle exiting insert mode via a control-C
inoremap <c-c> <c-o>:call InsertLeaveActions()<cr><c-c>
hi statusline guibg=green

" --------------------------------------------------------------------------------

" Fix back space in normal mode
nmap <BS> X
nmap <f3> <c-]>
nmap <c-w><f3> <c-w><c-]>
nmap <c-w>m <c-w>\| <c-w>_
nmap <space> <c-f>
nmap <silent> <c-w>c :bnext<cr>:bd #<cr>
nmap <silent> <C-Tab> :b #<cr>
nmap <silent> <C-PageUp> :bnext<CR>
nmap <silent> <C-PageDown> :bprevious<CR>


nmap <silent> <c-t> :execute "normal! \<c-a>"<cr>

" Fix stopsel behavior in Visual Mode
"vnoremap <Left> h
"vnoremap <Right> l
"vnoremap <Up> k
"vnoremap <Down> j
"vnoremap <Home> 0
"vnoremap <End> $

nnoremap <S-M-Left> <C-W>h
nnoremap <S-M-l> <C-W>h
nnoremap <S-M-Right> <C-W>l
nnoremap <S-M-h> <C-W>l
nnoremap <S-M-Up> <C-W>k
nnoremap <S-M-k> <C-W>k
nnoremap <S-M-Down> <C-W>j
nnoremap <S-M-j> <C-W>j

" --------------- RAILS
set nocompatible
syntax on
filetype plugin indent on
"helptags ~/.vim/doc

" --------------- LATEX
" REQUIRED. This makes vim invoke Latex-Suite when you open a tex file.
filetype plugin on

" IMPORTANT: win32 users will need to have 'shellslash' set so that latex
" can be called correctly.
" set shellslash

" IMPORTANT: grep will sometimes skip displaying the file name if you
" search in a singe file. This will confuse Latex-Suite. Set your grep
" program to always generate a file-name.
set grepprg=grep\ -nH\ $*

" OPTIONAL: This enables automatic indentation as you type.
" (Already set above)
" filetype indent on

" OPTIONAL: Starting with Vim 7, the filetype of empty .tex files defaults to
" 'plaintex' instead of 'tex', which results in vim-latex not being loaded.
" The following changes the default filetype back to 'tex':
let g:tex_flavor='latex'


let mapleader=','
map <leader>ew :e <C-R>=expand("%:p:h") . "/" <CR>
map <leader>es :sp <C-R>=expand("%:p:h") . "/" <CR>
map <leader>ev :vsp <C-R>=expand("%:p:h") . "/" <CR>
map <leader>et :tabe <C-R>=expand("%:p:h") . "/" <CR>
map <leader>t <C-]>

map <C-Up> <C-Y>
map <C-Down> <C-E>

"Map ctrl+n to toggle NERDtree
nmap <silent> <c-n> :NERDTreeToggle<CR>
nmap <silent> <c-p> :TlistToggle<CR>
"nmap <silent> <c-c> :FufCoverageFile<CR>
"nmap <silent> <c-t> :FufTag<CR>
nmap <silent> g<c-t> :FufTagWithCursorWord<CR>

autocmd FileType rb imap <buffer> <c-f> => 
autocmd FileType erb imap <buffer> <c-f> => 
nmap <c-a> ggVG

autocmd FileType vim setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd FileType tex setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd FileType latex setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd FileType cpp setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType java setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType jsp setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType xml setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType ant setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType ant setlocal iskeyword+=.
autocmd FileType ant setlocal iskeyword+=-
autocmd FileType jproperties setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType jproperties setlocal iskeyword+=.
autocmd FileType jproperties setlocal iskeyword+=-
autocmd FileType python setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab


hi SpellBad term=reverse ctermbg=2
hi SpellCap term=reverse ctermbg=2
hi SpellRare term=reverse ctermbg=2
hi SpellLocal term=reverse ctermbg=2

" INVISIBLES
" Shortcut to rapidly toggle `set list`
nmap <leader>i :set list!<CR>

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬

"Invisible character colors
highlight NonText guifg=#333333
highlight SpecialKey guifg=#333333
" highlight NonText guifg=#dadae9
" highlight SpecialKey guifg=#dadae9

vnoremap <Tab> >gv
vnoremap <S-Tab> <gv
nnoremap <Tab> >>
nnoremap <S-Tab> <<

function! Paste(mode)
  if a:mode == "v"
    normal gv
    normal "+P
    normal l
  elseif a:mode == "i"
    set virtualedit=all
    normal `^"+gP
    let &virtualedit = ""
  endif
endfunction

vnoremap <C-X> "+d
vnoremap <C-C> "+y
vnoremap <C-V> "+p
inoremap <C-V> <C-O>:call Paste("i")<CR>
" nnoremap <C-V> "+gPl
" vnoremap <C-V> :<C-U>call Paste("v")<CR>
vmap P "0p

" Visually select the text that was last edited/pasted
nmap gV `[v`]

" Bubble single lines
nmap <A-Up> [e
nmap <A-k> [e
nmap <A-Down> ]e
nmap <A-j> ]e

" Bubble multiple lines
vmap <A-Up> [egv
vmap <A-k> [egv
vmap <A-Down> ]egv
vmap <A-j> ]egv

" Copy current line
nmap <C-A-Up> "-yyp
nmap <C-A-k> "-yyp
nmap <C-A-Down> <C-A-Up>
nmap <C-A-j> <C-A-Up>

" Copy current lines
vmap <C-A-Up> <Esc>'<V'>"-y'>"-pgv
vmap <C-A-k> <Esc>'<V'>"-y'>"-pgv
vmap <C-A-Down> <Esc>'<V'>"-y"-Pgv
vmap <C-A-j> <Esc>'<V'>"-y"-Pgv

" Select a 'word' surrounding by spaces
vmap <SPACE> iW
"vmap <SPACE> :<BS><BS><BS><BS><BS>let b:old=@/<CR>gvh/ \\|$/e-1<CR>Ol? \\|^?e+1<CR>O:<BS><BS><BS><BS><BS>let @/=b:old<CR>gv

function! PutRegFilledToRange() range
  let l:fill = ''
  let l:lines = getreg()
  let l:lineStart = 0
  let l:linesLen = strlen(l:lines)
  let l:lineIndex = 0
  let l:linesNeeded = a:lastline - a:firstline + 1
  while l:lineIndex < l:linesNeeded 
    let l:lineEnd = matchend(l:lines, "\n\\|$", l:lineStart)
    let l:line = strpart(l:lines, l:lineStart, l:lineEnd - l:lineStart)
    if l:lines[l:lineEnd - 1] != "\n" 
      let l:line = l:line . "\n"
    endif
    let l:fill = l:fill . l:line
    let l:lineStart = l:lineEnd < l:linesLen ? l:lineEnd : 0
    let l:lineIndex = l:lineIndex + 1
  endwhile

  normal gv
  " This probably does not make much sense in any mode
  " other than block modes, but we will try to cope.
  if mode() == "\<C-V>" || mode() == "\<C-S>"
    let l:newMode = "\<C-V>"
  elseif mode() == 'v' || mode() == 's'
    let l:newMode = 'v'
  else
    let l:newMode = 'V'
  endif
  let l:origReg = getreg('')
  let l:origRegType = getregtype('')
  try
    call setreg('', l:fill, l:newMode)
    execute 'normal ' . v:count1 . 'p'
  finally
    call setreg('', l:origReg, l:origRegType)
  endtry
endfunction
vmap _f :call PutRegFilledToRange()<CR>

function! PutRegBeforeOrAfter(move) range
  execute "normal gv" . a:move . getreg(v:register) . "\<c-c>"
endfunction
vmap _I :call PutRegBeforeOrAfter('I')<CR>
vmap _A :call PutRegBeforeOrAfter('A')<CR>

function! FillInc() range
  let l:fill = ''
  let l:lineIndex = 0
  let l:linesNeeded = a:lastline - a:firstline + 1
  if getreg() =~ "[0-9]\+"
    let l:count = 0 + getreg()
  else
    let l:count = 1
  endif
  while l:lineIndex < l:linesNeeded
    let l:fill = l:fill . l:count . "\n"
    let l:count = l:count + 1
    let l:lineIndex = l:lineIndex + 1
  endwhile

"  echo l:fill
  normal gv
  " This probably does not make much sense in any mode
  " other than block modes, but we will try to cope.
  if mode() == "\<C-V>" || mode() == "\<C-S>"
    let l:newMode = "\<C-V>"
  elseif mode() == 'v' || mode() == 's'
    let l:newMode = 'v'
  else
    let l:newMode = 'V'
  endif
  let l:origReg = getreg('')
  let l:origRegType = getregtype('')
  try
    call setreg('', l:fill, l:newMode)
    execute 'normal ' . v:count1 . 'p'
  finally
    call setreg('', l:origReg, l:origRegType)
  endtry
endfunction

vmap _c :call FillInc()<CR>

"""" Copy matches of the last search to a register (default is the clipboard).
"""" Accepts a range (default is whole file).
"""" 'CopyMatches'   copy matches to clipboard (each match has \n added).
"""" 'CopyMatches x' copy matches to register x (clears register first).
"""" 'CopyMatches X' append matches to register x.
"""" We skip empty hits to ensure patterns using '\ze' don't loop forever.
"""command! -range=% -register CopyMatches call s:CopyMatches(<line1>, <line2>, '<reg>')
"""function! s:CopyMatches(line1, line2, reg)
"""  let hits = []
"""  for line in range(a:line1, a:line2)
"""    let txt = getline(line)
"""    let idx = match(txt, @/)
"""    while idx >= 0
"""      let end = matchend(txt, @/, idx)
"""      if end > idx
"""	call add(hits, strpart(txt, idx, end-idx))
"""      else
"""	let end += 1
"""      endif
"""      if @/[0] == '^'
"""        break  " to avoid false hits
"""      endif
"""      let idx = match(txt, @/, end)
"""    endwhile
"""  endfor
"""  if len(hits) > 0
"""    let reg = empty(a:reg) ? '+' : a:reg
"""    execute 'let @'.reg.' = join(hits, "\n") . "\n"'
"""  else
"""    echo 'No hits'
"""  endif
"""endfunction
"""
"""" Use 0"+y0 to clear the clipboard, then
""""    :g/pattern/call CopyMultiMatches()
"""" to copy all multiline hits (just the matching text).
"""" This is for when the match extends over multiple lines.
"""" Only the first match from each line is found.
"""" BUG: When searching for "^function.*\_s*let" the '.*' stops at the end
"""" of a line, but it greedily skips "\n" in the following (we copy too much).
"""function! CopyMultiMatches()
"""  let text = join(getline(".", "$"), "\n") . "\n"
"""  let @+ .= matchstr(text, @/) . "\n"
"""endfunction


" Remove all text except what matches the current search result
" The opposite of :%s///g (which clears all instances of the current search.
" Note: Clobbers the c register
function! ClearAllButMatches()
    let old = @c
    let @c=""
    %s//\=setreg('C', submatch(0), 'l')/g
    %d _
    put c
    0d _
    let @c = old
endfunction

function! AddToRegister(group)
  call setreg(v:register, getreg() . submatch(a:group), 'l')
  return submatch(0)
endfunction

function! YankAllMatched(...) range
  if a:0 == 0
    let l:group=0
  else
    let l:group=a:1
  endif
  call setreg(v:register, '', 'c')
  execute a:firstline . ',' . a:lastline . 's//\=AddToRegister(' . l:group . ')/g'
endfunction

" Copy all matched text to the specified register. Use as an optional
" argument a regex matching group.
command! -nargs=? -range=% YankAllMatched <line1>,<line2>call YankAllMatched(<args>)


" --------------------------------------------------------------------------------
" JAVA
" --------------------------------------------------------------------------------

nmap ga _f lvt;F h"tyf;hvT "ny][Opublic "tpa get"npT lllvUA() {return pa;}public void setpT lllvUA("tpa "npa) {this."npa = "npa;}


function! GetBufferList()
    return filter(range(1,bufnr('$')), 'buflisted(v:val)')
endfunction

function! GetMatchingBuffers(pattern)
    return filter(GetBufferList(), 'substitute(bufname(v:val), "\\\\", "/", "g") =~ a:pattern')
endfunction

function! ProcessMatchingBuffers(op, opdescr, pattern)
    let l:p = substitute(a:pattern, '\\', '/', 'g')
    let l:p = '\V\^' . l:p . '\$'
    let l:p = substitute(l:p, '\*', '\\.\\*', 'g')
    let l:p = substitute(l:p, '?', '\\.', 'g')
    echo "'" . l:p . "'"
    let l:matchList = GetMatchingBuffers(l:p)

    let l:count = len(l:matchList)
    if l:count < 1
        echo 'No buffers found matching pattern ' . a:pattern
        return
    endif

    if l:count == 1
        let l:suffix = ''
    else
        let l:suffix = 's'
    endif

    exec a:op . ' ' . join(l:matchList, ' ')

    echo a:opdescr . ' ' . l:count . ' buffer' . l:suffix . '.'
endfunction

command! -nargs=1 BW call ProcessMatchingBuffers('bw', 'Wiped', '<args>')
command! -nargs=1 BD call ProcessMatchingBuffers('bd', 'deleted', '<args>')




if filereadable($HOME . "/.vimrc_local")
  source $HOME/.vimrc_local
endif

