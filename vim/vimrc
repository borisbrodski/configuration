" Use runtime! my.vim to use other files

call pathogen#runtime_append_all_bundles()
call pathogen#helptags()
runtime macros/matchit.vim

if has('win32')
	source $HOME/vimfiles/bundle/snipmate/plugin/snipMate.vim
	"source $HOME/vimfiles/bundle/snipmate/autoload/snipMate.vim
	call GetSnippets("C:/Users/brodski.boris/vimfiles/bundle/snipmate/snippets", "tex")
	call GetSnippets("C:/Users/brodski.boris/vimfiles/snippets/", "ant")
endif

set showmatch " Show matching brackets.
set ignorecase " Search ignoring case
set smartcase " Do smart case matching
set hlsearch
set incsearch
set hidden
set mouse=a
set selectmode=
set mousemodel=popup
set keymodel=startsel ",stopsel
set selection=old
set backspace=indent,eol,start

" Fix stopsel behavior in Visual Mode
"vnoremap <Left> h
"vnoremap <Right> l
"vnoremap <Up> k
"vnoremap <Down> j
"vnoremap <Home> 0
"vnoremap <End> $

nnoremap <S-M-Left> <C-W>h
nnoremap <S-M-Right> <C-W>l
nnoremap <S-M-Up> <C-W>k
nnoremap <S-M-Down> <C-W>j

" --------------- RAILS
set nocompatible
syntax on
filetype plugin indent on
"helptags ~/.vim/doc

" --------------- LATEX
" REQUIRED. This makes vim invoke Latex-Suite when you open a tex file.
filetype plugin on

" IMPORTANT: win32 users will need to have 'shellslash' set so that latex
" can be called correctly.
" set shellslash

" IMPORTANT: grep will sometimes skip displaying the file name if you
" search in a singe file. This will confuse Latex-Suite. Set your grep
" program to always generate a file-name.
set grepprg=grep\ -nH\ $*

" OPTIONAL: This enables automatic indentation as you type.
" (Already set above)
" filetype indent on

" OPTIONAL: Starting with Vim 7, the filetype of empty .tex files defaults to
" 'plaintex' instead of 'tex', which results in vim-latex not being loaded.
" The following changes the default filetype back to 'tex':
let g:tex_flavor='latex'


let mapleader=','
map <leader>ew :e <C-R>=expand("%:p:h") . "/" <CR>
map <leader>es :sp <C-R>=expand("%:p:h") . "/" <CR>
map <leader>ev :vsp <C-R>=expand("%:p:h") . "/" <CR>
map <leader>et :tabe <C-R>=expand("%:p:h") . "/" <CR>
map <leader>t <C-]>

map <C-Up> <C-Y>
map <C-Down> <C-E>

nmap <silent> <C-PageUp> :bnext<CR>
nmap <silent> <C-PageDown> :bprevious<CR>

"Map ctrl+n to toggle NERDtree
nmap <silent> <c-n> :NERDTreeToggle<CR>
nmap <silent> <c-p> :TlistToggle<CR>
"nmap <silent> <c-c> :FufCoverageFile<CR>
"nmap <silent> <c-t> :FufTag<CR>
nmap <silent> g<c-t> :FufTagWithCursorWord<CR>

autocmd FileType rb imap <buffer> <c-f> => 
autocmd FileType erb imap <buffer> <c-f> => 
nmap <c-a> ggVG

autocmd FileType vim setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd FileType tex setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd FileType latex setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd FileType cpp setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType java setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType xml setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType ant setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType ant setlocal iskeyword+=.
autocmd FileType ant setlocal iskeyword+=-
autocmd FileType jproperties setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd FileType jproperties setlocal iskeyword+=.
autocmd FileType jproperties setlocal iskeyword+=-
autocmd FileType python setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab


hi SpellBad term=reverse ctermbg=2
hi SpellCap term=reverse ctermbg=2
hi SpellRare term=reverse ctermbg=2
hi SpellLocal term=reverse ctermbg=2

" INVISIBLES
" Shortcut to rapidly toggle `set list`
nmap <leader>i :set list!<CR>

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬

"Invisible character colors
highlight NonText guifg=#dadae9
highlight SpecialKey guifg=#dadae9

vnoremap <Tab> >gv
vnoremap <S-Tab> <gv
nnoremap <Tab> >>
nnoremap <S-Tab> <<

function! Paste(mode)
  if a:mode == "v"
    normal gv
    normal "+P
    normal l
  elseif a:mode == "i"
    set virtualedit=all
    normal `^"+gP
    let &virtualedit = ""
  endif
endfunction

vnoremap <C-X> "+d
vnoremap <C-C> "+y
vnoremap <C-V> "+p
inoremap <C-V> <C-O>:call Paste("i")<CR>
" nnoremap <C-V> "+gPl
" vnoremap <C-V> :<C-U>call Paste("v")<CR>

" Visually select the text that was last edited/pasted
nmap gV `[v`]

" Bubble single lines
nmap <A-Up> [e
nmap <A-Down> ]e

" Bubble multiple lines
vmap <A-Up> [egv
vmap <A-Down> ]egv

" Copy current line
nmap <C-A-Up> "-yyp
nmap <C-A-Down> <C-A-Up>

" Copy current lines
vmap <C-A-Up> <Esc>'<V'>"-y'>"-pgv
vmap <C-A-Down> <Esc>'<V'>"-y"-Pgv


function! PutRegFilledToRange() range
  let l:fill = ''
  let l:lines = getreg()
  let l:lineStart = 0
  let l:linesLen = strlen(l:lines)
  let l:lineIndex = 0
  let l:linesNeeded = a:lastline - a:firstline + 1
  while l:lineIndex < l:linesNeeded 
    let l:lineEnd = matchend(l:lines, "\n\\|$", l:lineStart)
    let l:line = strpart(l:lines, l:lineStart, l:lineEnd - l:lineStart)
    if l:lines[l:lineEnd - 1] != "\n" 
      let l:line = l:line . "\n"
    endif
    let l:fill = l:fill . l:line
    let l:lineStart = l:lineEnd < l:linesLen ? l:lineEnd : 0
    let l:lineIndex = l:lineIndex + 1
  endwhile

  normal gv
  " This probably does not make much sense in any mode
  " other than block modes, but we will try to cope.
  if mode() == "\<C-V>" || mode() == "\<C-S>"
    let l:newMode = "\<C-V>"
  elseif mode() == 'v' || mode() == 's'
    let l:newMode = 'v'
  else
    let l:newMode = 'V'
  endif
  let l:origReg = getreg('')
  let l:origRegType = getregtype('')
  try
    call setreg('', l:fill, l:newMode)
    execute 'normal ' . v:count1 . 'p'
  finally
    call setreg('', l:origReg, l:origRegType)
  endtry
endfunction
vmap _f :call PutRegFilledToRange()<CR>

function! FillInc() range
  let l:fill = ''
  let l:lineIndex = 0
  let l:linesNeeded = a:lastline - a:firstline + 1
  if getreg() =~ "[0-9]\+"
    let l:count = 0 + getreg()
  else
    let l:count = 1
  endif
  while l:lineIndex < l:linesNeeded
    let l:fill = l:fill . l:count . "\n"
    let l:count = l:count + 1
    let l:lineIndex = l:lineIndex + 1
  endwhile

"  echo l:fill
  normal gv
  " This probably does not make much sense in any mode
  " other than block modes, but we will try to cope.
  if mode() == "\<C-V>" || mode() == "\<C-S>"
    let l:newMode = "\<C-V>"
  elseif mode() == 'v' || mode() == 's'
    let l:newMode = 'v'
  else
    let l:newMode = 'V'
  endif
  let l:origReg = getreg('')
  let l:origRegType = getregtype('')
  try
    call setreg('', l:fill, l:newMode)
    execute 'normal ' . v:count1 . 'p'
  finally
    call setreg('', l:origReg, l:origRegType)
  endtry
endfunction

vmap _c :call FillInc()<CR>

if filereadable($HOME . "/.vimrc_local")
  source $HOME/.vimrc_local
endif

